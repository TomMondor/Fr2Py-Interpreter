from typing import Callable, Iterable
from utils.utils import is_valid_number
from tokenizer.tokens import *
from tokens_parser.ast_nodes import *
from interpreter.invalid_identifier_exception import InvalidIdentifierException
from interpreter.invalid_arguments_exception import InvalidArgumentsException
from interpreter.storage import Storage



class Interpreter:
    """Interpreter class for the language.
        Uses an AbstractSyntaxTree generated by a Parser object.
        If I am not mistaken, works like an AST_Walker.
    """
    def __init__(self, ast : AbstractSyntaxTree, storage : Storage, input_fct : (Callable[[str], str]) = input, output_fct : (Callable[[Iterable[str]], None]) = print):
        self.ast = ast
        self.storage = storage
        self.input_fct = input_fct
        self.output_fct = output_fct

    def interpret(self):
        """Interpret, run the program."""
        self.walk(self.ast)


    def walk(self, node : AST_Node):
        """The idea of this method (and walk_fallback_node()) is from Ruslan's blog, 
            see https://github.com/rspivak/lsbasi/blob/master/part9/python/spi.py#:~:text=def%20visit(self%2C%20node)%3A
        """
        method_name = 'walk_' + type(node).__name__
        walker = getattr(self, method_name, self.walk_fallback_node)
        return walker(node)

    def walk_fallback_node(self, node):
        raise NotImplementedError(f'NotImplementedError : No walk_{type(node).__name__} method implemented.')

    def walk_AbstractSyntaxTree(self, node):
        return self.walk_Block(node)

    def walk_Block(self, node):
        for child in node.children:
            self.walk(child)

    def walk_Number(self, node):
        return float(node.value)

    def walk_String(self, node):
        return node.value

    def walk_Variable(self, node):
        return self.storage.get(node.value, node.token.line_nbr)

    def walk_Assignment(self, node):
        right_value = self.walk(node.right)
        self.storage.store(node.left.value, right_value)

    def walk_BinaryOperation(self, node):
        if node.operator_value == TokenType.PLUS.value:
            return self.walk(node.left) + self.walk(node.right)
        elif node.operator_value == TokenType.MINUS.value:
            return self.walk(node.left) - self.walk(node.right)
        elif node.operator_value == TokenType.STAR.value:
            return self.walk(node.left) * self.walk(node.right)
        elif node.operator_value == TokenType.SLASH.value:
            return self.walk(node.left) / self.walk(node.right)
        elif node.operator_value == TokenType.EXPONENT.value:
            return self.walk(node.left) ** self.walk(node.right)
        elif node.operator_value == TokenType.EQUAL.value:
            return self.walk(node.left) == self.walk(node.right)
        elif node.operator_value == TokenType.NOT_EQUAL.value:
            return self.walk(node.left) != self.walk(node.right)
        elif node.operator_value == TokenType.LESS.value:
            return self.walk(node.left) < self.walk(node.right)
        elif node.operator_value == TokenType.LESS_EQUAL.value:
            return self.walk(node.left) <= self.walk(node.right)
        elif node.operator_value == TokenType.GREATER.value:
            return self.walk(node.left) > self.walk(node.right)
        elif node.operator_value == TokenType.GREATER_EQUAL.value:
            return self.walk(node.left) >= self.walk(node.right)
        elif node.operator_value == TokenType.AND.value:
            return self.walk(node.left) and self.walk(node.right)
        elif node.operator_value == TokenType.OR.value:
            return self.walk(node.left) or self.walk(node.right)
        else:
            raise NotImplementedError(f'NotImplementedError : No method implemented for {node.operator_value} operator.')

    def walk_UnaryOperation(self, node):
        if node.operator_value == TokenType.NOT.value:
            return not self.walk(node.right)

    def walk_IfStatement(self, node):
        if self.walk(node.condition):
            self.walk(node.then_block)
        else:
            self.walk(node.else_block)

    def walk_FunctionCall(self, node):
        if node.function_name == "demande":
            user_input = self.input_fct(f"{self.walk(node.args[0])} ")
            return float(user_input) if is_valid_number(user_input) else user_input
        elif node.function_name == "affiche":
            output = ""
            for arg in node.args:
                output += str(self.walk(arg)) + " "
            self.output_fct(output + "\n")
        else:
            function_node = self.storage.get(node.function_name, node.function.line_nbr)
            args = [self.walk(arg) for arg in node.args]
            self.storage.enter_scope(function_node.function_name)
            self.assign_function_call_params(function_node.params, args)
            self.walk(function_node.body)
            return_value = self.walk(function_node.return_statement)
            self.storage.exit_scope()
            return return_value

    def walk_ReturnStatement(self, node):
        return self.walk(node.expression) if not node.returns_nothing() else None

    def walk_FunctionDefinition(self, node):
        self.storage.store(node.function_name, node)

    def assign_function_call_params(self, params : list[Variable], args : list[Union[int, float, str]]):
        """Checks if given arguments match the declared parameters.
            If so, assigns args to variables (named as the parameters) in the function's scope.

            Args:
                params (list[Variable]): parameters defined in the function definiton
                args (list[Union[int, float, str]]): arguments of the function call
        """
        if len(params) != len(args):
            raise InvalidArgumentsException
        for param, arg in zip(params, args):
            self.storage.store(param.value, arg)
