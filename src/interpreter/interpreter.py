from tokenizer.tokens import *
from tokens_parser.ast_nodes import *
from interpreter.invalid_identifier_exception import InvalidIdentifierException



class Interpreter:
    """Interpreter class for the language.
        Uses an AbstractSyntaxTree generated by a Parser object.
        If I am not mistaken, works like an AST_Walker.

        TODO: The symbol table currently is a simple Python dictionary that does double duty as a memory space.
        TODO: Functions are currently not supported.
    """
    def __init__(self, ast : AbstractSyntaxTree):
        self.ast = ast
        self.global_scope = {}


    def run(self):
        """Run the program."""
        self.walk(self.ast)


    def walk(self, node : AST_Node):
        """The idea of this method (and fallback_walker()) is from Ruslan's blog, 
            see https://github.com/rspivak/lsbasi/blob/master/part9/python/spi.py#:~:text=def%20visit(self%2C%20node)%3A
        """
        method_name = 'walk_' + type(node).__name__
        walker = getattr(self, method_name, self.fallback_walker)
        return walker(node)

    def fallback_walker(self, node):
        raise NotImplementedError(f'NotImplementedError : No walk_{type(node).__name__} method implemented.')

    def walk_AbstractSyntaxTree(self, node):
        return self.walk_Block(node)

    def walk_Block(self, node):
        for child in node.children:
            self.walk(child)

    def walk_Number(self, node):
        return node.value

    def walk_String(self, node):
        return node.value

    def walk_Variable(self, node):
        #TODO To be modified when support for functions is added.
        if node.value in self.global_scope:
            return self.global_scope[node.value]
        else:
            raise InvalidIdentifierException(node.value, node.token.line_nbr)

    def walk_Assignment(self, node):
        #TODO To be modified when support for functions is added. 
        self.global_scope[node.left.value] = self.walk(node.right)

    def walk_BinaryOperation(self, node):
        pass #TODO implement, for each logical and arithmetic operator.

    def walk_UnaryOperation(self, node):
        pass #TODO implement, for each logical and arithmetic operator (NOT only).

    def walk_IfStatement(self, node):
        if self.walk(node.condition):
            self.walk(node.then_block)
        else:
            self.walk(node.else_block)

    def walk_FunctionCall(self, node):
        if node.function_name == "demande":
            #utiliser la fonction python input() et retourner un Node correspondant?
            pass #TODO
        elif node.function_name == "affiche":
            #utiliser la fonction python print() et retourner un Node correspondant?
            pass #TODO
        else:
            pass #TODO implement for user-defined functions.

    def walk_ReturnStatement(self, node):
        pass #TODO implement user-defined functions.

    def walk_FunctionDefinition(self, node):
        pass #TODO implement user-defined functions.
