from tokenizer.tokens import *
from tokenizer.token_type_exception import TokenTypeException
from tokens_parser.ast_nodes import *
from tokens_parser.invalid_syntax_exception import InvalidSyntaxException
from tokens_parser.unexpected_eof_exception import UnexpectedEndOfFileException


class Parser:
    """Parser class for the language.
        Uses a list of tokens generated by a Tokenizer object.
        Produces an abstract syntax tree, using the AST_Node class hierarchy.
    """

    def __init__(self, tokenized_program : list[list[Token]]):
        self.tokenized_program : list[list[Token]] = tokenized_program
        self.line = 0
        self.position_in_line = 0
        self.ast = AbstractSyntaxTree([])

    def parse(self):
        program_line, line_nbr = self.eat_program_line()
        while not self.is_parsing_finished():
            self.ast.append(self.parse_program_line(program_line, line_nbr))
            print(program_line)
            program_line, line_nbr = self.eat_program_line()

    def eat_program_line(self) -> tuple[list[Token], int]:
        if self.line < len(self.tokenized_program):
            program_line = self.tokenized_program[self.line]
            self.line += 1
            return program_line, self.line - 1
        else:
            raise UnexpectedEndOfFileException(self.line)

    def is_parsing_finished(self) -> bool:
        return self.line >= len(self.tokenized_program)

    def parse_program_line(self, program_line : list[Token], line_nbr : int) -> AST_Node:
        """
        full line expressions:
            assignment
            if block
            function definition
            function call
        in line expressions:
            function call
            logical expression
            math expression
            variable
            number
            string
        """
        first_token = program_line[0]
        second_token = program_line[1] if len(program_line) > 1 else Token(-1, TokenType.NOT_A_TOKEN)
        if first_token.type == TokenType.FUNCTION and second_token.type == TokenType.FUNCTION_NAME:
            return self.parse_function_definition(program_line)
        elif first_token.type == TokenType.IF:
            return self.parse_if_block(program_line)
        elif first_token.type == TokenType.FUNCTION_NAME and second_token.type == TokenType.LEFT_PAREN:
            return self.parse_function_call(program_line)
        elif first_token.type == TokenType.VARIABLE_NAME and second_token.type == TokenType.EQUAL:
            return self.parse_assignment(program_line)
        else:
            raise InvalidSyntaxException(program_line, line_nbr)

    def parse_assignment(self, program_line : list[Token]) -> Assignment:
        if len(program_line) < 3:
            raise InvalidSyntaxException(program_line, program_line[0].line_nbr)
        expression = self.parse_expression(program_line[2:])
        variable = Variable(program_line[0])
        return Assignment(variable, expression)

    def parse_if_block(self, program_line : list[Token]) -> IfStatement:
        condition = self.parse_logical_expression(program_line[1:])
        then_line, line_nbr = self.eat_program_line()
        if len(then_line) != 1 or then_line[0].type != TokenType.THEN:
            raise InvalidSyntaxException(then_line, line_nbr)

        then_block = Block([])
        has_else_block = False
        else_block = Block([])
        line = [Token(-1, TokenType.NOT_A_TOKEN)]
        while line[0].type != TokenType.END_IF:
            line, line_nbr = self.eat_program_line()
            if line[0].type == TokenType.ELSE:
                if len(line) != 1:
                    raise InvalidSyntaxException(line, line_nbr)
                has_else_block = True
                continue
            else:
                parsed_line = self.parse_program_line(line, line_nbr)
                then_block.append(parsed_line) if not has_else_block else else_block.append(parsed_line)

        # when while ends
        if len(line) != 1:
            raise InvalidSyntaxException(line, line_nbr)
        return IfStatement(condition, then_block, else_block)

    def parse_function_definition(self, program_line : list[Token]) -> FunctionDefinition:
        pass #TODO à implémenter
        # lines = []
        # #lines += eat_program_line() jusqu'à rencontrer un "retourne"
        # params = [] # de la "(" à la ")", appeler parse_expression() entre chaque virgule
        # body = Block([]) #à remplir en appelant parse_program_line() pour chq ligne entre la ")" et le "retourne"
        # return_statement_tokens : list[Token] = [] #à déterminer
        # return_statement = ReturnStatement(self.parse_expression(return_statement_tokens))
        # return FunctionDefinition(program_line[1], params, body, return_statement)

    def parse_expression(self, tokens : list[Token]) -> Expression:
        pass #TODO à implémenter
        # appeler parse_function_call, parse_logical_expression, parse_math_expression
        # ou créer une Variable, Number ou String

    def parse_function_call(self, tokens : list[Token]) -> FunctionCall:
        pass #TODO à implémenter

    def parse_logical_expression(self, tokens : list[Token]) -> BinaryOperation:
        pass #TODO à implémenter

    def parse_math_expression(self, tokens : list[Token]) -> BinaryOperation:
        pass #TODO à implémenter
