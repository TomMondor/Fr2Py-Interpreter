from tokenizer.tokens import *
from tokenizer.token_type_exception import TokenTypeException
from tokens_parser.ast_nodes import *
from tokens_parser.invalid_syntax_exception import InvalidSyntaxException
from tokens_parser.unexpected_eof_exception import UnexpectedEndOfFileException


class Parser:
    """Parser class for the language.
        Uses a list of tokens generated by a Tokenizer object.
        Produces an abstract syntax tree, using the AST_Node class hierarchy.
    """

    def __init__(self, tokenized_program : list[list[Token]]):
        self.tokenized_program : list[list[Token]] = tokenized_program
        self.line = 0
        self.position_in_line = 0
        self.ast = AbstractSyntaxTree([])

    def parse(self):
        program_line, line_nbr = self.eat_program_line()
        while not self.is_parsing_finished():
            self.ast.append(self.parse_program_line(program_line, line_nbr))
            print(program_line)
            program_line, line_nbr = self.eat_program_line()

    def eat_program_line(self) -> tuple[list[Token], int]:
        if self.line < len(self.tokenized_program):
            program_line = self.tokenized_program[self.line]
            self.line += 1
            return program_line, self.line - 1
        else:
            raise UnexpectedEndOfFileException(self.line)

    def is_parsing_finished(self) -> bool:
        return self.line >= len(self.tokenized_program)

    def parse_program_line(self, program_line : list[Token], line_nbr : int) -> AST_Node:
        """
        full line expressions:
            assignment
            if block
            function definition
            function call
        in line expressions:
            function call
            logical expression
            math expression
            variable
            number
            string
        """
        first_token = program_line[0]
        second_token = program_line[1] if len(program_line) > 1 else Token(-1, TokenType.NOT_A_TOKEN)
        if first_token.type == TokenType.FUNCTION:
            return self.parse_function_definition(program_line)
        elif first_token.type == TokenType.IF:
            return self.parse_if_block(program_line)
        elif first_token.type == TokenType.FUNCTION_NAME and second_token.type == TokenType.LEFT_PAREN:
            return self.parse_function_call(program_line)
        elif first_token.type == TokenType.VARIABLE_NAME and second_token.type == TokenType.EQUAL:
            return self.parse_assignment(program_line)
        else:
            raise InvalidSyntaxException(program_line, line_nbr)

    def parse_assignment(self, program_line : list[Token]) -> Assignment:
        pass #TODO à implémenter

    def parse_if_block(self, program_line : list[Token]) -> IfStatement:
        pass #TODO à implémenter

    def parse_function_definition(self, program_line : list[Token]) -> FunctionDefinition:
        pass #TODO à implémenter

    def parse_function_call(self, program_line : list[Token]) -> FunctionCall:
        pass #TODO à implémenter

    def parse_logical_expression(self, program_line : list[Token]) -> BinaryOperation:
        pass #TODO à implémenter

    def parse_math_expression(self, program_line : list[Token]) -> BinaryOperation:
        pass #TODO à implémenter
